name: Stock Scanner V2-New (Telegram)

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

on:
  schedule:
    - cron: '*/5 * * * 1-5'   # every 5 min, weekdays (UTC)
  workflow_dispatch:
    inputs:
      RUN_AFTER_HOURS:
        type: boolean
        description: 'Allow running outside US market hours?'
        default: false
      ALWAYS_NOTIFY:
        type: boolean
        description: 'Send a summary even if there are no NEW alerts?'
        default: true
      PING_ON_START:
        type: boolean
        description: 'Send a startup ping?'
        default: false
      PING_ON_END:
        type: boolean
        description: 'Send a completion ping?'
        default: false
      TICKERS:
        type: string
        description: 'Optional override list (comma/space/semicolon/pipe separated)'
        default: ''
      PROFILE:
        type: choice
        description: 'Preset'
        options: ['balanced (core)', 'conservative (strict)', 'aggressive (loose)']
        default: 'balanced (core)'
      DEBUG_DETAIL:
        type: choice
        description: 'Include per-ticker gate flags & bottlenecks in the output?'
        options: ['false', 'true']
        default: 'false'
      ADVANCED_JSON:
        type: string
        description: 'Optional overrides as JSON'
        default: ''

jobs:
  scan:
    runs-on: ubuntu-latest
    timeout-minutes: 12

    env:
      TZ: America/New_York
      CADENCE_MIN: '55'   # strict minimum interval between successes
      TOLERANCE_MIN: '4'  # small modulo window to avoid multiple cron hits
      # Single-line expression to avoid YAML parse errors:
      RUN_AFTER_HOURS: "${{ (github.event_name == 'workflow_dispatch' && inputs.RUN_AFTER_HOURS) || vars.RUN_AFTER_HOURS || secrets.RUN_AFTER_HOURS || false }}"

    steps:
      # --- Restore small cadence cache (stores last success timestamp) ---
      - name: Restore cadence cache
        id: cadcache
        uses: actions/cache/restore@v4
        with:
          path: .cadence_cache
          key: cadence-${{ runner.os }}-v1
          restore-keys: |
            cadence-${{ runner.os }}-v1-
            cadence-${{ runner.os }}-

      # --- Gate FIRST; everything else depends on it ---
      - name: Gate cadence (sets outputs ok=yes|no)
        id: gate
        shell: bash
        run: |
          set -euo pipefail
          ok=yes
          reason=""

          # Current NY time
          dow=$(TZ=America/New_York date +%u)    # 1..7 (Mon..Sun)
          hh=$(TZ=America/New_York date +%H)
          mm=$(TZ=America/New_York date +%M)
          mins=$((10#$hh*60 + 10#$mm))

          open=$((9*60 + 30))    # 09:30
          close=$((16*60))       # 16:00

          cad=${CADENCE_MIN:-55}
          tol=${TOLERANCE_MIN:-4}
          run_after_hours="${RUN_AFTER_HOURS}"
          run_after_hours="${run_after_hours,,}"   # lowercase normalize

          # In regular trading hours?
          in_rth=no
          if [ "$dow" -ge 1 ] && [ "$dow" -le 5 ] && [ $mins -ge $open ] && [ $mins -lt $close ]; then
            in_rth=yes
          fi

          # 1) Block weekends always
          if [ "$dow" -ge 6 ]; then
            ok=no; reason="weekend"
          fi

          # 2) If outside RTH and after-hours not allowed, block
          if [ "$ok" = "yes" ] && [ "$in_rth" = "no" ] && [ "$run_after_hours" != "true" ]; then
            ok=no; reason="outside RTH"
          fi

          # 3) Modulo cadence window (anchored to 09:30 ET) for predictability
          if [ "$ok" = "yes" ]; then
            delta=$(( mins - open ))
            rem=$(( ( (delta % cad) + cad ) % cad ))   # safe modulo
            if [ $rem -le $tol ] || [ $rem -ge $((cad - tol)) ]; then
              : # on cadence
            else
              ok=no; reason="off cadence (rem=$rem tol=$tol)"
            fi
          fi

          # 4) STRICT minimum interval since last success (≥ CADENCE_MIN)
          mkdir -p .cadence_cache
          last_path=".cadence_cache/last_run_epoch.txt"
          now_epoch=$(date -u +%s)
          if [ -f "$last_path" ]; then
            last_epoch=$(cat "$last_path" 2>/dev/null || echo 0)
          else
            last_epoch=0
          fi

          if [ "$ok" = "yes" ] && [ "$last_epoch" -gt 0 ]; then
            elapsed=$(( (now_epoch - last_epoch) / 60 ))
            if [ $elapsed -lt $cad ]; then
              ok=no; reason="interval gate: elapsed=${elapsed}min < cad=${cad}min"
            fi
          fi

          HM=$(TZ=America/New_York date +'%H:%M')
          {
            echo "now=$HM"
            echo "ok=$ok"
            echo "reason=$reason"
            echo "in_rth=$in_rth"
            echo "rem=${rem:-na}"
          } >> "$GITHUB_OUTPUT"
          echo "Gate: ok=$ok in_rth=$in_rth rem=${rem:-na} cad=$cad tol=$tol reason='${reason}' NY=$HM"

      - name: Skip (off cadence / outside hours)
        if: steps.gate.outputs.ok != 'yes'
        run: echo "Skipping: ${{ steps.gate.outputs.reason }} @ ${{ steps.gate.outputs.now }} NY"

      # --- Heavy steps guarded by the gate ---
      - name: Checkout
        if: steps.gate.outputs.ok == 'yes'
        uses: actions/checkout@v4

      - name: Set up Python
        if: steps.gate.outputs.ok == 'yes'
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Cache pip
        if: steps.gate.outputs.ok == 'yes'
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: ${{ runner.os }}-pip-

      - name: Install deps
        if: steps.gate.outputs.ok == 'yes'
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          else
            pip install pandas numpy yfinance requests certifi
          fi

      - name: Compute week key
        if: steps.gate.outputs.ok == 'yes'
        run: echo "WEEK_KEY=$(TZ=America/New_York date +%G-%V)" >> $GITHUB_ENV

      - name: Restore scanner cache
        if: steps.gate.outputs.ok == 'yes'
        id: scancache
        uses: actions/cache/restore@v4
        with:
          path: .scanner_cache
          key: scanner-cache-${{ runner.os }}-${{ env.WEEK_KEY }}
          restore-keys: |
            scanner-cache-${{ runner.os }}-

      - name: Expand PROFILE/ADVANCED_JSON → env
        if: steps.gate.outputs.ok == 'yes'
        shell: bash
        env:
          PROFILE: ${{ inputs.PROFILE }}
          ADVANCED_JSON: ${{ inputs.ADVANCED_JSON }}
          DEBUG_DETAIL: ${{ inputs.DEBUG_DETAIL }}
        run: |
          python - <<'PY'
          import os, json, sys
          profile = (os.environ.get("PROFILE","balanced (core)") or "balanced (core)").strip().lower()
          presets = {
            "balanced (core)": {"ENABLE_4H": True, "ENFORCE_4H_ANCHORED_VWAP": True,
              "REGIME_SYMBOL": "SPY", "REGIME_DOWNGRADE_TO_WATCH": True,
              "MIN_20D_DOLLAR_VOL": 5_000_000, "VOL_UP_LOOKBACK": 10, "VOL_UP_MULT": 1.2,
              "BUY_LOWER_BAND_ATR_MULT": 0.5, "BUY_UPPER_BAND_ATR_MULT": 0.25,
              "MIN_RR": 1.5, "DIV_MIN": 2},
            "conservative (strict)": {"ENABLE_4H": True, "ENFORCE_4H_ANCHORED_VWAP": True,
              "REGIME_SYMBOL": "SPY", "REGIME_DOWNGRADE_TO_WATCH": True,
              "MIN_20D_DOLLAR_VOL": 10_000_000, "VOL_UP_LOOKBACK": 12, "VOL_UP_MULT": 1.4,
              "BUY_LOWER_BAND_ATR_MULT": 0.75, "BUY_UPPER_BAND_ATR_MULT": 0.5,
              "MIN_RR": 2.0, "DIV_MIN": 3},
            "aggressive (loose)": {"ENABLE_4H": True, "ENFORCE_4H_ANCHORED_VWAP": False,
              "REGIME_SYMBOL": "SPY", "REGIME_DOWNGRADE_TO_WATCH": False,
              "MIN_20D_DOLLAR_VOL": 2_000_000, "VOL_UP_LOOKBACK": 8, "VOL_UP_MULT": 1.0,
              "BUY_LOWER_BAND_ATR_MULT": 0.4, "BUY_UPPER_BAND_ATR_MULT": 0.2,
              "MIN_RR": 1.2, "DIV_MIN": 1}
          }
          cfg = dict(presets.get(profile, presets["balanced (core)"]))
          raw = (os.environ.get("ADVANCED_JSON","") or "").strip()
          if raw:
            try:
              user = json.loads(raw)
              if not isinstance(user, dict): raise ValueError("must be a JSON object")
              cfg.update(user)
            except Exception as e:
              print("Invalid ADVANCED_JSON:", e)
              sys.exit(1)
          mapping = {"ENABLE_4H":"IDE_ENABLE_4H","ENFORCE_4H_ANCHORED_VWAP":"ENFORCE_4H_ANCHORED_VWAP",
                     "REGIME_SYMBOL":"REGIME_SYMBOL","REGIME_DOWNGRADE_TO_WATCH":"REGIME_DOWNGRADE_TO_WATCH",
                     "MIN_20D_DOLLAR_VOL":"MIN_20D_DOLLAR_VOL","VOL_UP_LOOKBACK":"VOL_UP_LOOKBACK",
                     "VOL_UP_MULT":"VOL_UP_MULT","BUY_LOWER_BAND_ATR_MULT":"BUY_LOWER_BAND_ATR_MULT",
                     "BUY_UPPER_BAND_ATR_MULT":"BUY_UPPER_BAND_ATR_MULT","MIN_RR":"MIN_RR","DIV_MIN":"DIV_MIN"}
          def as_bool(v): return "true" if str(v).lower() in ("1","true","yes","on","y") else "false"
          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
            for k, dst in mapping.items():
              if k in cfg:
                v = cfg[k]
                if isinstance(v, bool): v = as_bool(v)
                f.write(f"{dst}={v}\n")
            f.write(f"DEBUG_DETAIL={(os.environ.get('DEBUG_DETAIL','false').lower())}\n")
          print("Effective profile:", profile)
          print("Effective config:", json.dumps(cfg, separators=(',',':')))
          PY

      - name: Run scanner
        if: steps.gate.outputs.ok == 'yes'
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          TELEGRAM_CHAT_IDS: ${{ secrets.TELEGRAM_CHAT_IDS }}
          MARKET_ONLY: ${{ env.RUN_AFTER_HOURS == 'true' && 'false' || 'true' }}
          ALWAYS_NOTIFY: ${{ github.event_name == 'workflow_dispatch' && (inputs.ALWAYS_NOTIFY && 'true' || 'false') || 'true' }}
          TELEGRAM_PING_ON_START: ${{ inputs.PING_ON_START && 'true' || 'false' }}
          TELEGRAM_PING_ON_END: ${{ inputs.PING_ON_END && 'true' || 'false' }}
          TICKERS: ${{ inputs.TICKERS }}
          CACHE_DIR: .scanner_cache
          NOTIFY_PREFIX: "[Enhanced Version V2] "
        run: |
          PYTHONUNBUFFERED=1 python scanner_dual_tf_vp_spyder_telegram_loop_dip5.py

      # --- Stamp success time & persist it so next run enforces ≥55 min ---
      - name: Stamp last run time
        if: steps.gate.outputs.ok == 'yes'
        run: |
          mkdir -p .cadence_cache
          date -u +%s > .cadence_cache/last_run_epoch.txt

      - name: Save cadence cache
        if: steps.gate.outputs.ok == 'yes'
        uses: actions/cache/save@v4
        with:
          path: .cadence_cache
          key: cadence-${{ runner.os }}-v1-${{ github.run_id }}

      - name: Upload CSV + state as artifact
        if: steps.gate.outputs.ok == 'yes' || failure()
        uses: actions/upload-artifact@v4
        with:
          name: scanner-output
          path: |
            scanner_dual_tf_vp_dip4.csv
            .scanner_cache/alerts_dip4_seen.json

      - name: Save scanner cache
        if: steps.gate.outputs.ok == 'yes' && steps.scancache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: .scanner_cache
          key: scanner-cache-${{ runner.os }}-${{ env.WEEK_KEY }}
